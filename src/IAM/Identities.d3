domain IAM {

    context Identities {

        aggregate Identity 
        {
            root entity Account inherits Core.Base.BaseEntity {
                enum Types {
                    User,
                    ExternalSystem,
                    InternalService
                }

                Type:Types
                Name:string
                isActive: boolean

                contacts: List[ContactInfo]

                # account specific unique secret is, for account specific sign in operations (like TOTP, Hash)
                accountSecret: string
            }

            valueobject ContactInfo
            {
                contactType: string
                email: string
                phoneNumber : string
            }

            # Two-factor authentication configuration
            valueobject TwoFactorConfiguration {
                enum Methods {
                    # Time-based One-Time Password (e.g. Google Authenticator)
                    TOTP,
                    # SMS-based OTP
                    SMS,
                    # Email-based OTP
                    Email
                }
                enabled: boolean
                method: Methods
                phoneNumber: string
                email:string
            }

            # Base type for all authentication methods
            entity Auth inherits Core.Base.BaseEntity {
                enum Methods {
                    Email,
                    ActiveDirectory,
                    KAU,
                    Certificate
                }
                # Defines the type of authentication method
                method: Methods
                isActive: boolean

                accountId: string
            }

            # Password-based authentication
            entity EmailAuth inherits Auth {
                email: string
                isEmailConfirmed: boolean

                # Hashed password
                passwordHash: string
                # Salt used for hashing
                passwordSalt: string
                # old password hashes
                passwordHistory: List[string] 
                # password expiration time
                passwordExpiresAt: date

                 # Optional two-factor authentication settings (TOTP, SMS, Email)
                twoFactor: TwoFactorConfiguration
            }

            # Active Directory-based authentication
            entity ADAuth inherits Auth {
                # Active Directory domain
                LdapDomainId: string
                # Active Directory username
                userName: string

                 # Optional two-factor authentication settings (TOTP, SMS, Email)
                twoFactor: TwoFactorConfiguration
            }

            # Certificate-based authentication
            entity CertificateAuth inherits Auth {
                # csak KIADOTT cert után számolható
                certificateThumbprint: string
                serialNumber: string
                issuer: string
                subject: string
                # SPKI hash - CSR-ből is képezhető
                publicKeyHash: string
                validFrom: datetime
                validUntil: datetime
                isRevoked: boolean
                revocationReason: string
                revokedAt: datetime
            }

            # KAU Ügyfélkapu authentication
            entity KAUAuth inherits Auth {
                # Government-issued unique identifier (Ügyfélkapu ID)
                KAUUserId: string
                # User’s full legal name as returned by the service
                legalName: string
                # Email address verified by the service (optional)
                email: string
                # Optional two-factor authentication settings (TOTP, SMS, Email)
                twoFactor: TwoFactorConfiguration            
            }

            entity LoginAuditEventLog inherits Core.Base.BaseEntity, Core.Auditing.AuditLog {
                AccountType:Account.Types
                authMethod:Auth.Methods
            }

            entity AccountAuditTrail inherits Core.Base.BaseEntity, Core.Auditing.AuditTrail {
                accountId: string
                accountName: string
            }
        }

        acl CertificateAuthorityACL {
            # CSR aláírása és kész cert visszaadása
            command signCsr(csrPem:string, profile:string) : bytes    # DER cert vagy PEM string is lehet
            command revoke(serialNumber:string, reason:string) : boolean
        }
        
        aggregate Ldap
        {
            root entity LdapDomain inherits Core.Base.BaseEntity {
                valueobject DomainController {
                    # Hostname or IP address of the DC
                    host: string
                    # LDAP or LDAPS port (e.g. 389 or 636)
                    port: integer
                }

                # Fully Qualified Domain Name (e.g. yourdomain.local)
                name: string
                # Optional description or notes
                description: string

                # NetBIOS name (e.g. YOURDOMAIN)
                netbiosName: string
                # List of Domain Controller hostnames or IP addresses
                domainControllers: List[DomainController]

                # Base Distinguished Name (where LDAP queries start, e.g. DC=yourdomain,DC=local)
                baseDn: string

                # Whether to use secure LDAP (LDAPS)
                useSecureLdap: boolean

                # Service account username used for directory queries (if required)
                serviceAccountUser: string
                # Service account password (should be stored securely/encrypted)
                serviceAccountPassword: string
            }

            entity LdapDomainAuditTrail inherits Core.Base.BaseEntity, Core.Auditing.AuditTrail {
                domainId: string
                domainName: string
            }
        }

        service AccountService {
            valueobject AccountWithAuth
            {
                account:Identity.Account
                auth:Identity.Auth
            }

            # Finds a user account by email address
            query findAccountByEmailAuth( email:string ) : AccountWithAuth
            # Finds a user account by email address
            query findAccountByADCredentrials( ldapDomain:Ldap.LdapDomain, username:string ) : AccountWithAuth
            # Finds a user account by KAU id
            query findAccountKAUUserId( kauUserId:string ) : AccountWithAuth

            valueobject AccountData {
                Type: Identity.Account.Types
                Name: string
                isActive: boolean
                contacts: List[Identity.ContactInfo]
            }
            command createAccount( data:AccountData ) : Identity.Account
            command updateAccount( accountId:string, etag:string, data:AccountData ) : Identity.Account
        }

        repository AccountRepository {
            command createAccount( account:Identity.Account ) : Identity.Account
            command updateAccount( account:Identity.Account ) : Identity.Account
            command getAccount( id:string ) : Identity.Account
            command getAllAccount() : List[Identity.Account]

            query findByName( name:string ) : Identity.Account
        }

        service AccountAuthService {
            command setAuthActive( accountId:string, authId:string, etag:string, isActive:boolean ) : Identity.Auth

            // ===== Email & Password =====
            command createEmailAuth(accountId:string, email:string, password:string, enableTwoFactor:boolean, twoFactorMethod:Identity.TwoFactorConfiguration.Methods, twoFactorPhoneNumber:string, twoFactorEmail:string) : Identity.EmailAuth
            command changePassword(accountId:string, authId:string, etag:string, oldPassword:string, newPassword:string) : Identity.EmailAuth
            command setEmailTwoFactor(accountId:string, authId:string, etag:string, enabled:boolean, method:Identity.TwoFactorConfiguration.Methods, phoneNumber:string, email:string) : Identity.EmailAuth
            command confirmEmail(confirmationToken:string) : boolean
            command ForgottPassword( accountId:string, authId:string, url:string ) : boolean
            command ResetPassword( token:string, newPassword:string ) : boolean

            // ===== Active Directory (LDAP) =====
            command CreateADAuth(accountId:string, ldapDomainId:string, userName:string, enableTwoFactor:boolean, twoFactorMethod:Identity.TwoFactorConfiguration.Methods, twoFactorPhoneNumber:string, twoFactorEmail:string) : Identity.ADAuth
            command UpdateADAccount(accountId:string, authId:string, etag:string, ldapDomainId:string, userName:string) : Identity.ADAuth
            command SetADTwoFactor(accountId:string, authId:string, etag:string, enabled:boolean, method:Identity.TwoFactorConfiguration.Methods, phoneNumber:string, email:string) : Identity.ADAuth

            // ===== KAÜ =====
            command CreateKAUAuth(accountId:string, kauUserId:string, enableTwoFactor:boolean, twoFactorMethod:Identity.TwoFactorConfiguration.Methods, twoFactorPhoneNumber:string, twoFactorEmail:string) : Identity.KAUAuth
            command SetKAUTwoFactor(accountId:string, authId:string, etag:string, enabled:boolean, method:Identity.TwoFactorConfiguration.Methods, phoneNumber:string, email:string) : Identity.KAUAuth

            // ===== Certificate =====
            command CreateCertificateFromCSR(accountId:string, csrPem:string, profile:string) : Identity.CertificateAuth
            command RevokeCertificate(accountId:string, authId:string, etag:string, reason:string) : Identity.CertificateAuth
        }

        repository AuthRepository {
            command createAuth( auth:Identity.Auth ) : Identity.Auth
            command updateAuth( auth:Identity.Auth ) : Identity.Auth

            query getAuth( accountId:string, authId:string ) : Identity.Auth
            query listAuthsForAccount( accountId:string ) : List[Identity.Auth]
            query listAuthsForAccountByMethod( accountId:string, method:Identity.Auth.Methods ) : List[Identity.Auth]

            // ---- EMAIL & PASSWORD ----
            query getEmailAuth( accountId:string, authId:string ) : Identity.EmailAuth
            // invariáns/egyediség ellenőrzéshez
            query findEmailAuthByEmail( email:string ) : Identity.EmailAuth

            // ---- ACTIVE DIRECTORY (LDAP) ----
            query getADAuth( accountId:string, authId:string ) : Identity.ADAuth
            // invariáns/egyediség: domain + userName
            query findADAuthByDomainAndUser( ldapDomainId:string, userName:string ) : Identity.ADAuth
            query listADAuthsByDomain( ldapDomainId:string ) : List[Identity.ADAuth]

            // ---- KAÜ ----
            query getKAUAuth( accountId:string, authId:string ) : Identity.KAUAuth
            // invariáns/egyediség: KAUUserId
            query findKAUAuthByUserId( kauUserId:string ) : Identity.KAUAuth

            // ---- CERTIFICATE ----
            query getCertificateAuth( accountId:string, authId:string ) : Identity.CertificateAuth
            // invariáns/egyediség: thumbprint vagy serialNumber
            query findCertificateAuthByThumbprint( thumbprint:string ) : Identity.CertificateAuth
            query findCertificateAuthBySerial( serialNumber:string ) : Identity.CertificateAuth
        }

        service LdapDomainService {
            command RegisterLdapDomain( ldapDomain:Ldap.LdapDomain ) : Ldap.LdapDomain
            command UpdateRegisteredLdapDomain( ldapDomain:Ldap.LdapDomain ) : Ldap.LdapDomain
        }

        repository LdapDomainRepository {
            command insertLdapDomain( ldapDomain:Ldap.LdapDomain ) : Ldap.LdapDomain
            command updateLdapDomain( ldapDomain:Ldap.LdapDomain ) : Ldap.LdapDomain
            command getLdapDomain( id:string ) : Ldap.LdapDomain
            command getAllLdapDomain() : List[Ldap.LdapDomain]
        }

        service LoginService {
            command LoginWithEmailPassword( email:string, password:string ) : LoginIF.v1.LoginResultDTO
            command LoginWithAD( username:string, password:string ) : LoginIF.v1.LoginResultDTO
            command Login2FA( code:string ) : LoginIF.v1.TokensDTO

            command RefreshTokens( totp:string ) : LoginIF.v1.TokensDTO

            query GetKAULoginURL( redirectUrl:string, backendCallbackUrl:string ) : string

            valueobject KAUCallbackResponse
            {
                returnUrl:string
                result:LoginIF.v1.LoginResultDTO
            }
            command KAUCallback( code:string, state:string ) : KAUCallbackResponse
        }

        @internal_api(grpc,rest)
        @public_api(rest, collection="Admin")
        interface IdentityAdminIF version 1 {
            dto LdapDomainDTO {
                @system_field id:string
                @system_field etag:string
                @system_field LastUpdate:datetime

                dto DomainController {
                    # Hostname or IP address of the DC
                    host: string
                    # LDAP or LDAPS port (e.g. 389 or 636)
                    port: integer
                }

                # Fully Qualified Domain Name (e.g. yourdomain.local)
                name: string
                # Optional description or notes
                description: string

                # NetBIOS name (e.g. YOURDOMAIN)
                netbiosName: string
                # List of Domain Controller hostnames or IP addresses
                domainControllers: List[DomainController]

                # Base Distinguished Name (where LDAP queries start, e.g. DC=yourdomain,DC=local)
                baseDn: string

                # Whether to use secure LDAP (LDAPS)
                useSecureLdap: boolean

                # Service account username used for directory queries (if required)
                serviceAccountUser: string
                # Service account password (should be stored securely/encrypted)
                serviceAccountPassword: string
            }

            dto LdapDomainSummaryDTO
            {
                id:string
                # Fully Qualified Domain Name (e.g. yourdomain.local)
                name: string
                # Optional description or notes
                description: string
            }

            command RegisterLdapDomain( ldap:LdapDomainDTO ) : LdapDomainDTO
            command UpdateRegisteredLdapDomain( ldap:LdapDomainDTO ) : LdapDomainDTO
            query GetAllRegisteredLdapDomain() : List[LdapDomainSummaryDTO]
            query GetRegisteredLdapDomain( id:string ) : LdapDomainDTO

            enum AccountTypes {
                User,
                ExternalSystem,
                InternalService
            }

            dto AccountSummaryDTO {
                @system_field id:string
                Type:AccountTypes
                Name:string
                isActive: boolean
            }

            dto AccountDTO {
                @system_field id:string
                @system_field etag:string
                @system_field LastUpdate:datetime

                data:AccountDataDTO
            }

            dto AccountDataDTO {
                Type:AccountTypes
                Name:string
                isActive: boolean
                contacts: List[ContactInfo]
            }

            dto ContactInfo
            {
                contactType: string
                email: string
                phoneNumber : string
            }

            command getAllAccount() : List[AccountSummaryDTO]
            command getAccount( id:string ) : AccountDTO
            command createAccount( username:string, accountType:AccountTypes ) : AccountDTO
            command updateAccount( accountId:string, etag:string, data:AccountDataDTO ) : AccountDTO

            dto AuthDTO
            {
                @system_field id:string
                @system_field etag:string
                @system_field LastUpdate:datetime

                enum Methods {
                    Email,
                    ActiveDirectory,
                    KAU,
                    Certificate
                }
                method: Methods
                isActive: boolean
            }
            command listAuthsForAccount( accountId:string ) : List[AuthDTO]
            command setActiveForAuth( accountId:string, authId:string, etag:string,  isActive:boolean ) : AuthDTO

            dto TwoFactorConfigurationDTO {
                enum Methods {
                    # Time-based One-Time Password (e.g. Google Authenticator)
                    TOTP,
                    # SMS-based OTP
                    SMS,
                    # Email-based OTP
                    Email
                }
                enabled: boolean
                method: Methods
                phoneNumber: string
                email:string
            }

            # Password-based authentication
            dto EmailAuthDTO {
                @system_field id:string
                @system_field etag:string
                @system_field LastUpdate:datetime
                isActive:boolean

                email: string
                isEmailConfirmed: boolean
                passwordExpiresAt: date
                twoFactor: TwoFactorConfigurationDTO
            }
            command createtEmailAuth( accountId:string, email:string, initialPassword:string, twoFactor: TwoFactorConfigurationDTO ) : EmailAuthDTO
            command getEmailAuth( accountId:string, authId:string ) : EmailAuthDTO
            command changePasswordOnEmailAuth( accountId:string, authId:string, etag:string, newPassword:string ) : EmailAuthDTO
            command setTwoFactorOnEmailAuth(accountId:string, authId:string, etag:string, twoFactor:TwoFactorConfigurationDTO) : EmailAuthDTO
            command confirmEmail(token:string) : boolean

             # Active Directory-based authentication
            dto ADAuthDTO {
                @system_field id:string
                @system_field etag:string
                @system_field LastUpdate:datetime
                isActive: boolean

                # Active Directory domain
                LdapDomainId: string
                LdapDomainName: string
                # Active Directory username
                userName: string

                 # Optional two-factor authentication settings (TOTP, SMS, Email)
                twoFactor: TwoFactorConfigurationDTO
            }
            command createADAuth(accountId:string, ldapDomainId:string, adUsername:string, twoFactor: TwoFactorConfigurationDTO) : ADAuthDTO
            command getADAuth( accountId:string, authId:string ) : ADAuthDTO
            command setTwoFactorOnADAuth(accountId:string, authId:string, etag:string, twoFactor:TwoFactorConfigurationDTO) : ADAuthDTO

            # KAU Ügyfélkapu authentication
            dto KAUAuthDTO  {
                @system_field id:string
                @system_field etag:string
                @system_field LastUpdate:datetime
                isActive: boolean

                # Government-issued unique identifier (Ügyfélkapu ID)
                KAUUserId: string
                # User’s full legal name as returned by the service
                legalName: string
                # Email address verified by the service (optional)
                email: string
                # Optional two-factor authentication settings (TOTP, SMS, Email)
                twoFactor: TwoFactorConfigurationDTO
            }
            command createKAUAuth(accountId:string, kauUserId:string, twoFactor:TwoFactorConfigurationDTO) : KAUAuthDTO
            command getKAUAuth( accountId:string, authId:string ) : KAUAuthDTO
            command setTwoFactorOnKAUAuth(accountId:string, authId:string, etag:string, twoFactor:TwoFactorConfigurationDTO) : KAUAuthDTO

             # Certificate-based authentication
            dto CertificateAuthDTO {
                @system_field id:string
                @system_field etag:string
                @system_field LastUpdate:datetime
                isActive: boolean

                certificateThumbprint: string
                serialNumber: string
                issuer: string
                subject: string
                publicKeyHash: string
                validFrom: datetime
                validUntil: datetime
                isRevoked: boolean
                revocationReason: string
                revokedAt: datetime
            }
            
            dto CsrInputDTO {
                csrPem: string
                # CA profil/sablon (opcionális)
                profile: string           
            }
            command createCertificateAuthFromCSR(accountId:string, data:CsrInputDTO) : CertificateAuthDTO
            command revokeCertificate(accountId:string, authId:string, etag:string, reason:string ) : CertificateAuthDTO
            command getCertificateAuth( accountId:string, authId:string ) : CertificateAuthDTO
        }


        @internal_api(grpc,rest)
        @public_api(grpc, rest, collection="BFF")
        interface LoginIF version 1 {
            dto TokensDTO {
                # Access token used for authentication
                AccessToken: string
                # Expiration date and time of the access token
                AccessTokenExpiresAt: datetime

                # Refresh token used to obtain a new access token
                RefreshToken: string
                # Expiration date and time of the refresh token
                RefreshTokenExpiresAt: datetime
            }

            enum SignInResult {
                # Login was successful
                Ok,
                # Invalid username or password provided
                InvalidUserNameOrPassword,
                # Email has not been confirmed by the user
                EmailNotConfirmed,
                # The user account is deactivated or locked
                UserIsNotActive,
                # The password has expired and needs to be changed
                PasswordExpired,

                # for LDAP auththentication: when username does not contain the domainname
                DomainNotSpecified,
                # for LDAP auththentication: when the domain is not alloed to use the system
                DomainNotRegistered,
                # for LDAP auththentication: when the domain use is not added for the system
                DomainUserNotRegistered,

                # for KAÜ auththentication: When token exchange is failed, or invalid token
                KAUTokenError,
                # for KAÜ auththentication: when no user registered in the system with given KAÜ user
                KAUUserNotFound,
            }

            dto LoginResultDTO {
                # The result of the login attempt
                result: SignInResult
                # Tokens returned when login is successful
                tokens: TokensDTO
                # Indicates whether two-factor authentication is required
                requires2FA: boolean
            }

            # Login using email and password credentials
            command LoginWithEmailPassword( email:string, password:string ) : LoginResultDTO
            command ChangePassword( email:string, oldPassword:string, newPassword:string )
            command ForgottPassword( email:string, url:string )
            command ResetPassword( token:string, newPassword:string )

            # Complete login with Active Directory
            command LoginWithAD( username:string, password:string ) : LoginResultDTO

            # Complete login with two-factor authentication (TOTP)
            command Login2FA( code:string ) : TokensDTO

            # refresh bearer tokens
            command RefreshTokens( refreshToken:string ) : TokensDTO

            # getting the KAU url, expects the frontend url, where the frontend must be redirected
            # the redirect url format is: {redirectUrl}/?accessToken={string}&refreshToken={string&requires2FA={boolean}&accessTokenExpiresAt={string}&refreshTokenExpiresAt={string}
            # Generates the KAÜ login URL with a signed state containing the frontend returnUrl.
            # Flow:
            # 1. Browser calls this endpoint (GetKAULoginUrl) and passes the desired frontend returnUrl.
            # 2. Backend builds the KAÜ authorize URL with its own callback URL and the signed state.
            # 3. Browser is redirected to KAÜ login page.
            # 4. KAÜ authenticates the user and redirects the browser to the backend callback URL with code + state.
            # 5. Backend exchanges the code for tokens and finally redirects the browser to the original frontend returnUrl.
            # Note: For local development KAÜ must be able to call the backend callback URL (use ngrok/dev tunnel).
            # returns: the KAU url, where the browser must be redirected.
            query GetKAULoginURL( redirectUrl:string ) : string
        }
    }

    context Access {
    }
}
