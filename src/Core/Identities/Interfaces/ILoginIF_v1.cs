
// <auto-generated>
//     This code was generated by d3i.interpreter
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

using Core.Identities;
using Google.Protobuf.WellKnownTypes;
using ServiceKit.Net;

namespace Core.Identities
{
	public partial interface ILoginIF_v1
	{
		/// <summary>
		///  Login using email and password credentials
		/// </summary>
		/// <return>ILoginIF_v1.LoginResultDTO</return>
		public Task<Response<ILoginIF_v1.LoginResultDTO>> LoginWithEmailPassword(CallingContext ctx, string email, string password);

		/// <summary>
		///  Complete login with Active Directory
		/// </summary>
		/// <return>ILoginIF_v1.LoginResultDTO</return>
		public Task<Response<ILoginIF_v1.LoginResultDTO>> LoginWithAD(CallingContext ctx, string username, string password);

		/// <summary>
		///  Complete login with two-factor authentication (TOTP)
		/// </summary>
		/// <return>ILoginIF_v1.TokensDTO</return>
		public Task<Response<ILoginIF_v1.TokensDTO>> Login2FA(CallingContext ctx, string code);

		/// <summary>
		///  refresh bearer tokens
		/// </summary>
		/// <return>ILoginIF_v1.TokensDTO</return>
		public Task<Response<ILoginIF_v1.TokensDTO>> RefreshTokens(CallingContext ctx, string refreshToken);

		/// <summary>
		///  getting the KAU url, expects the frontend url, where the frontend must be redirected
		///  the redirect url format is: {redirectUrl}/?accessToken={string}&refreshToken={string&requires2FA={boolean}&accessTokenExpiresAt={string}&refreshTokenExpiresAt={string}
		///  Generates the KAÜ login URL with a signed state containing the frontend returnUrl.
		///  Flow:
		///  1. Browser calls this endpoint (GetKAULoginUrl) and passes the desired frontend returnUrl.
		///  2. Backend builds the KAÜ authorize URL with its own callback URL and the signed state.
		///  3. Browser is redirected to KAÜ login page.
		///  4. KAÜ authenticates the user and redirects the browser to the backend callback URL with code + state.
		///  5. Backend exchanges the code for tokens and finally redirects the browser to the original frontend returnUrl.
		///  Note: For local development KAÜ must be able to call the backend callback URL (use ngrok/dev tunnel).
		///  returns: the KAU url, where the browser must be redirected.
		/// </summary>
		/// <return>string</return>
		public Task<Response<string>> GetKAULoginURL(CallingContext ctx, string redirectUrl);


		public enum SignInResult
		{
			/// Login was successful
			Ok,

			/// Invalid username or password provided
			InvalidUserNameOrPassword,

			/// Email has not been confirmed by the user
			EmailNotConfirmed,

			/// The user account is deactivated or locked
			UserIsNotActive,

			/// The password has expired and needs to be changed
			PasswordExpired,

			/// for LDAP auththentication: when username does not contain the domainname
			DomainNotSpecified,

			/// for LDAP auththentication: when the domain is not alloed to use the system
			DomainNotRegistered,

			/// for LDAP auththentication: when the domain use is not added for the system
			DomainUserNotRegistered,

			/// for KAÜ auththentication: When token exchange is failed, or invalid token
			KAUTokenError,

			/// for KAÜ auththentication: when no user registered in the system with given KAÜ user
			KAUUserNotFound,

		}
		#region GrpcMapping
		public static class SignInResultMappings
		{
			public static Protos.LoginIF_v1.SignInResult ToGrpc( ILoginIF_v1.SignInResult @this )
			{
				return @this switch
				{
					ILoginIF_v1.SignInResult.Ok => Protos.LoginIF_v1.SignInResult.Ok,
					ILoginIF_v1.SignInResult.InvalidUserNameOrPassword => Protos.LoginIF_v1.SignInResult.InvalidUserNameOrPassword,
					ILoginIF_v1.SignInResult.EmailNotConfirmed => Protos.LoginIF_v1.SignInResult.EmailNotConfirmed,
					ILoginIF_v1.SignInResult.UserIsNotActive => Protos.LoginIF_v1.SignInResult.UserIsNotActive,
					ILoginIF_v1.SignInResult.PasswordExpired => Protos.LoginIF_v1.SignInResult.PasswordExpired,
					ILoginIF_v1.SignInResult.DomainNotSpecified => Protos.LoginIF_v1.SignInResult.DomainNotSpecified,
					ILoginIF_v1.SignInResult.DomainNotRegistered => Protos.LoginIF_v1.SignInResult.DomainNotRegistered,
					ILoginIF_v1.SignInResult.DomainUserNotRegistered => Protos.LoginIF_v1.SignInResult.DomainUserNotRegistered,
					ILoginIF_v1.SignInResult.KAUTokenError => Protos.LoginIF_v1.SignInResult.KautokenError,
					ILoginIF_v1.SignInResult.KAUUserNotFound => Protos.LoginIF_v1.SignInResult.KauuserNotFound,
					_ => throw new NotImplementedException(), 
				};
			}

			public static ILoginIF_v1.SignInResult FromGrpc( Protos.LoginIF_v1.SignInResult @this )
			{
				return @this switch
				{
					Protos.LoginIF_v1.SignInResult.Ok => ILoginIF_v1.SignInResult.Ok,
					Protos.LoginIF_v1.SignInResult.InvalidUserNameOrPassword => ILoginIF_v1.SignInResult.InvalidUserNameOrPassword,
					Protos.LoginIF_v1.SignInResult.EmailNotConfirmed => ILoginIF_v1.SignInResult.EmailNotConfirmed,
					Protos.LoginIF_v1.SignInResult.UserIsNotActive => ILoginIF_v1.SignInResult.UserIsNotActive,
					Protos.LoginIF_v1.SignInResult.PasswordExpired => ILoginIF_v1.SignInResult.PasswordExpired,
					Protos.LoginIF_v1.SignInResult.DomainNotSpecified => ILoginIF_v1.SignInResult.DomainNotSpecified,
					Protos.LoginIF_v1.SignInResult.DomainNotRegistered => ILoginIF_v1.SignInResult.DomainNotRegistered,
					Protos.LoginIF_v1.SignInResult.DomainUserNotRegistered => ILoginIF_v1.SignInResult.DomainUserNotRegistered,
					Protos.LoginIF_v1.SignInResult.KautokenError => ILoginIF_v1.SignInResult.KAUTokenError,
					Protos.LoginIF_v1.SignInResult.KauuserNotFound => ILoginIF_v1.SignInResult.KAUUserNotFound,
					_ => throw new NotImplementedException(), 
				};
			}

		}
		#endregion GrpcMapping
		public partial class TokensDTO : IEquatable<TokensDTO>
		{
			/// Access token used for authentication
			public string AccessToken { get; set; }
			/// Expiration date and time of the access token
			public DateTime AccessTokenExpiresAt { get; set; }
			/// Refresh token used to obtain a new access token
			public string RefreshToken { get; set; }
			/// Expiration date and time of the refresh token
			public DateTime RefreshTokenExpiresAt { get; set; }

			#region Clone 
			public virtual TokensDTO Clone()
			{
				TokensDTO clone = new();

				clone.AccessToken = new string(AccessToken.ToCharArray());
				clone.AccessTokenExpiresAt = AccessTokenExpiresAt;
				clone.RefreshToken = new string(RefreshToken.ToCharArray());
				clone.RefreshTokenExpiresAt = RefreshTokenExpiresAt;

				return clone;
			}
			#endregion Clone 

			#region Equals & HashCode 
			public bool Equals( TokensDTO other )
			{
				if (other is null) return false;

				if(AccessToken != other.AccessToken) return false;
				if(AccessTokenExpiresAt != other.AccessTokenExpiresAt) return false;
				if(RefreshToken != other.RefreshToken) return false;
				if(RefreshTokenExpiresAt != other.RefreshTokenExpiresAt) return false;

				return true;
			}

			public override bool Equals(object obj) => Equals(obj as TokensDTO);

			public override int GetHashCode()
			{
				var hash = new HashCode();
				hash.Add(AccessToken);
				hash.Add(AccessTokenExpiresAt);
				hash.Add(RefreshToken);
				hash.Add(RefreshTokenExpiresAt);

				return hash.ToHashCode();
			}
			#endregion Equals & HashCode 

			#region GrpcMapping
			public static Protos.LoginIF_v1.TokensDTO ToGrpc( ILoginIF_v1.TokensDTO @this )
			{
				Protos.LoginIF_v1.TokensDTO result = new();

				result.AccessToken = @this.AccessToken;
				result.AccessTokenExpiresAt = Timestamp.FromDateTime(@this.AccessTokenExpiresAt);
				result.RefreshToken = @this.RefreshToken;
				result.RefreshTokenExpiresAt = Timestamp.FromDateTime(@this.RefreshTokenExpiresAt);

				return result;
			}
			public static ILoginIF_v1.TokensDTO FromGrpc( Protos.LoginIF_v1.TokensDTO @from )
			{
				ILoginIF_v1.TokensDTO result = new();

				result.AccessToken = @from.AccessToken;
				result.AccessTokenExpiresAt = @from.AccessTokenExpiresAt.ToDateTime();
				result.RefreshToken = @from.RefreshToken;
				result.RefreshTokenExpiresAt = @from.RefreshTokenExpiresAt.ToDateTime();

				return result;
			}
			#endregion GrpcMapping
		}

		public partial class LoginResultDTO : IEquatable<LoginResultDTO>
		{
			/// The result of the login attempt
			public ILoginIF_v1.SignInResult result { get; set; }
			/// Tokens returned when login is successful
			public ILoginIF_v1.TokensDTO tokens { get; set; }
			/// Indicates whether two-factor authentication is required
			public bool requires2FA { get; set; }

			#region Clone 
			public virtual LoginResultDTO Clone()
			{
				LoginResultDTO clone = new();

				clone.result = result;

				// clone of tokens
				clone.tokens = tokens?.Clone();
				clone.requires2FA = requires2FA;

				return clone;
			}
			#endregion Clone 

			#region Equals & HashCode 
			public bool Equals( LoginResultDTO other )
			{
				if (other is null) return false;

				if(result != other.result) return false;

				// equals of tokens
				if(tokens == null && other.tokens != null ) return false;
				if(tokens != null && tokens.Equals(other.tokens) == false ) return false;
				if(requires2FA != other.requires2FA) return false;

				return true;
			}

			public override bool Equals(object obj) => Equals(obj as LoginResultDTO);

			public override int GetHashCode()
			{
				var hash = new HashCode();
				hash.Add(result);

				// hash of tokens
				if(tokens != null ) hash.Add(tokens);
				hash.Add(requires2FA);

				return hash.ToHashCode();
			}
			#endregion Equals & HashCode 

			#region GrpcMapping
			public static Protos.LoginIF_v1.LoginResultDTO ToGrpc( ILoginIF_v1.LoginResultDTO @this )
			{
				Protos.LoginIF_v1.LoginResultDTO result = new();

				result.Result = ILoginIF_v1.SignInResultMappings.ToGrpc( @this.result );
				result.Tokens = @this.tokens != null ? ILoginIF_v1.TokensDTO.ToGrpc( @this.tokens ) : null;
				result.Requires2FA = @this.requires2FA;

				return result;
			}
			public static ILoginIF_v1.LoginResultDTO FromGrpc( Protos.LoginIF_v1.LoginResultDTO @from )
			{
				ILoginIF_v1.LoginResultDTO result = new();

				result.result = ILoginIF_v1.SignInResultMappings.FromGrpc( @from.Result) ;
				result.tokens = @from.Tokens != null ? ILoginIF_v1.TokensDTO.FromGrpc( @from.Tokens ) : null;
				result.requires2FA = @from.Requires2FA;

				return result;
			}
			#endregion GrpcMapping
		}

	}
}
